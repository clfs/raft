package raft

// Edit if desired. Code generated by "fzgen ./...".

import (
	"io"
	"testing"
	"time"

	"github.com/thepudds/fzgen/fuzzer"
)

func Fuzz_AppendEntriesRequest_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *AppendEntriesRequest
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_AppendEntriesResponse_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *AppendEntriesResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_Configuration_Clone(f *testing.F) {
	f.Fuzz(func(t *testing.T, path string) {
		c, err := ReadPeersJSON(path)
		if err != nil {
			return
		}
		c.Clone()
	})
}

func Fuzz_DiscardSnapshotSink_Cancel(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *DiscardSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d)
		if d == nil {
			return
		}

		d.Cancel()
	})
}

func Fuzz_DiscardSnapshotSink_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *DiscardSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d)
		if d == nil {
			return
		}

		d.Close()
	})
}

func Fuzz_DiscardSnapshotSink_ID(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *DiscardSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d)
		if d == nil {
			return
		}

		d.ID()
	})
}

func Fuzz_DiscardSnapshotSink_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *DiscardSnapshotSink
		var b []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d, &b)
		if d == nil {
			return
		}

		d.Write(b)
	})
}

// skipping Fuzz_DiscardSnapshotStore_Create because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.Transport

func Fuzz_DiscardSnapshotStore_Open(f *testing.F) {
	f.Fuzz(func(t *testing.T, id string) {
		d := NewDiscardSnapshotStore()
		d.Open(id)
	})
}

func Fuzz_FileSnapshotSink_Cancel(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *FileSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Cancel()
	})
}

func Fuzz_FileSnapshotSink_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *FileSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Close()
	})
}

func Fuzz_FileSnapshotSink_ID(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *FileSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.ID()
	})
}

func Fuzz_FileSnapshotSink_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *FileSnapshotSink
		var b []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &b)
		if s == nil {
			return
		}

		s.Write(b)
	})
}

// skipping Fuzz_FileSnapshotStore_Create because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.Transport

func Fuzz_FileSnapshotStore_List(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var base string
		var retain int
		var logOutput io.Writer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&base, &retain, &logOutput)

		f1, err := NewFileSnapshotStore(base, retain, logOutput)
		if err != nil {
			return
		}
		f1.List()
	})
}

func Fuzz_FileSnapshotStore_Open(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var base string
		var retain int
		var logOutput io.Writer
		var id string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&base, &retain, &logOutput, &id)

		f1, err := NewFileSnapshotStore(base, retain, logOutput)
		if err != nil {
			return
		}
		f1.Open(id)
	})
}

func Fuzz_FileSnapshotStore_ReapSnapshots(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var base string
		var retain int
		var logOutput io.Writer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&base, &retain, &logOutput)

		f1, err := NewFileSnapshotStore(base, retain, logOutput)
		if err != nil {
			return
		}
		f1.ReapSnapshots()
	})
}

func Fuzz_InmemSnapshotSink_Cancel(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *InmemSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Cancel()
	})
}

func Fuzz_InmemSnapshotSink_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *InmemSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Close()
	})
}

func Fuzz_InmemSnapshotSink_ID(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *InmemSnapshotSink
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.ID()
	})
}

func Fuzz_InmemSnapshotSink_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *InmemSnapshotSink
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &p)
		if s == nil {
			return
		}

		s.Write(p)
	})
}

// skipping Fuzz_InmemSnapshotStore_Create because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.Transport

func Fuzz_InmemSnapshotStore_Open(f *testing.F) {
	f.Fuzz(func(t *testing.T, id string) {
		m := NewInmemSnapshotStore()
		m.Open(id)
	})
}

func Fuzz_InmemStore_DeleteRange(f *testing.F) {
	f.Fuzz(func(t *testing.T, min uint64, max uint64) {
		i := NewInmemStore()
		i.DeleteRange(min, max)
	})
}

func Fuzz_InmemStore_Get(f *testing.F) {
	f.Fuzz(func(t *testing.T, key []byte) {
		i := NewInmemStore()
		i.Get(key)
	})
}

func Fuzz_InmemStore_GetLog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var index uint64
		var log *Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&index, &log)
		if log == nil {
			return
		}

		i := NewInmemStore()
		i.GetLog(index, log)
	})
}

func Fuzz_InmemStore_GetUint64(f *testing.F) {
	f.Fuzz(func(t *testing.T, key []byte) {
		i := NewInmemStore()
		i.GetUint64(key)
	})
}

func Fuzz_InmemStore_Set(f *testing.F) {
	f.Fuzz(func(t *testing.T, key []byte, val []byte) {
		i := NewInmemStore()
		i.Set(key, val)
	})
}

func Fuzz_InmemStore_SetUint64(f *testing.F) {
	f.Fuzz(func(t *testing.T, key []byte, val uint64) {
		i := NewInmemStore()
		i.SetUint64(key, val)
	})
}

func Fuzz_InmemStore_StoreLog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var log *Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&log)
		if log == nil {
			return
		}

		i := NewInmemStore()
		i.StoreLog(log)
	})
}

func Fuzz_InmemStore_StoreLogs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var logs []*Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&logs)

		i := NewInmemStore()
		i.StoreLogs(logs)
	})
}

func Fuzz_InmemTransport_AppendEntries(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var id ServerID
		var t3 ServerAddress
		var args *AppendEntriesRequest
		var resp *AppendEntriesResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &id, &t3, &args, &resp)
		if i == nil || args == nil || resp == nil {
			return
		}

		i.AppendEntries(id, t3, args, resp)
	})
}

func Fuzz_InmemTransport_AppendEntriesPipeline(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var id ServerID
		var t3 ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &id, &t3)
		if i == nil {
			return
		}

		i.AppendEntriesPipeline(id, t3)
	})
}

func Fuzz_InmemTransport_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i)
		if i == nil {
			return
		}

		i.Close()
	})
}

// skipping Fuzz_InmemTransport_Connect because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.Transport

func Fuzz_InmemTransport_Consumer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i)
		if i == nil {
			return
		}

		i.Consumer()
	})
}

func Fuzz_InmemTransport_DecodePeer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var buf []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &buf)
		if i == nil {
			return
		}

		i.DecodePeer(buf)
	})
}

func Fuzz_InmemTransport_Disconnect(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var peer ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &peer)
		if i == nil {
			return
		}

		i.Disconnect(peer)
	})
}

func Fuzz_InmemTransport_DisconnectAll(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i)
		if i == nil {
			return
		}

		i.DisconnectAll()
	})
}

func Fuzz_InmemTransport_EncodePeer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var id ServerID
		var p ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &id, &p)
		if i == nil {
			return
		}

		i.EncodePeer(id, p)
	})
}

func Fuzz_InmemTransport_InstallSnapshot(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var id ServerID
		var t3 ServerAddress
		var args *InstallSnapshotRequest
		var resp *InstallSnapshotResponse
		var d6 io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &id, &t3, &args, &resp, &d6)
		if i == nil || args == nil || resp == nil {
			return
		}

		i.InstallSnapshot(id, t3, args, resp, d6)
	})
}

func Fuzz_InmemTransport_LocalAddr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i)
		if i == nil {
			return
		}

		i.LocalAddr()
	})
}

func Fuzz_InmemTransport_RequestVote(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var id ServerID
		var t3 ServerAddress
		var args *RequestVoteRequest
		var resp *RequestVoteResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &id, &t3, &args, &resp)
		if i == nil || args == nil || resp == nil {
			return
		}

		i.RequestVote(id, t3, args, resp)
	})
}

// skipping Fuzz_InmemTransport_SetHeartbeatHandler because parameters include func, chan, or unsupported interface: func(github.com/hashicorp/raft.RPC)

func Fuzz_InmemTransport_TimeoutNow(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *InmemTransport
		var id ServerID
		var t3 ServerAddress
		var args *TimeoutNowRequest
		var resp *TimeoutNowResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &id, &t3, &args, &resp)
		if i == nil || args == nil || resp == nil {
			return
		}

		i.TimeoutNow(id, t3, args, resp)
	})
}

func Fuzz_InstallSnapshotRequest_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *InstallSnapshotRequest
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_InstallSnapshotResponse_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *InstallSnapshotResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_LogCache_DeleteRange(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *LogCache
		var min uint64
		var max uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &min, &max)
		if c == nil {
			return
		}

		c.DeleteRange(min, max)
	})
}

func Fuzz_LogCache_FirstIndex(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *LogCache
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.FirstIndex()
	})
}

func Fuzz_LogCache_GetLog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *LogCache
		var idx uint64
		var log *Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &idx, &log)
		if c == nil || log == nil {
			return
		}

		c.GetLog(idx, log)
	})
}

func Fuzz_LogCache_LastIndex(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *LogCache
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.LastIndex()
	})
}

func Fuzz_LogCache_StoreLog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *LogCache
		var log *Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &log)
		if c == nil || log == nil {
			return
		}

		c.StoreLog(log)
	})
}

func Fuzz_LogCache_StoreLogs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *LogCache
		var logs []*Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &logs)
		if c == nil {
			return
		}

		c.StoreLogs(logs)
	})
}

func Fuzz_MockFSM_Apply(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *MockFSM
		var log *Log
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &log)
		if m == nil || log == nil {
			return
		}

		m.Apply(log)
	})
}

func Fuzz_MockFSM_Logs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *MockFSM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m)
		if m == nil {
			return
		}

		m.Logs()
	})
}

func Fuzz_MockFSM_Restore(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *MockFSM
		var inp io.ReadCloser
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &inp)
		if m == nil {
			return
		}

		m.Restore(inp)
	})
}

func Fuzz_MockFSM_Snapshot(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *MockFSM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m)
		if m == nil {
			return
		}

		m.Snapshot()
	})
}

func Fuzz_MockFSMConfigStore_StoreConfiguration(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *MockFSMConfigStore
		var index uint64
		var config Configuration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &index, &config)
		if m == nil {
			return
		}

		m.StoreConfiguration(index, config)
	})
}

// skipping Fuzz_MockSnapshot_Persist because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.SnapshotSink

func Fuzz_MockSnapshot_Release(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *MockSnapshot
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m)
		if m == nil {
			return
		}

		m.Release()
	})
}

func Fuzz_NetworkTransport_AppendEntries(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var id ServerID
		var t3 ServerAddress
		var args *AppendEntriesRequest
		var resp *AppendEntriesResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &id, &t3, &args, &resp)
		if config == nil || args == nil || resp == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.AppendEntries(id, t3, args, resp)
	})
}

func Fuzz_NetworkTransport_AppendEntriesPipeline(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var id ServerID
		var t3 ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &id, &t3)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.AppendEntriesPipeline(id, t3)
	})
}

func Fuzz_NetworkTransport_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.Close()
	})
}

func Fuzz_NetworkTransport_CloseStreams(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.CloseStreams()
	})
}

func Fuzz_NetworkTransport_Consumer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.Consumer()
	})
}

func Fuzz_NetworkTransport_DecodePeer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var buf []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &buf)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.DecodePeer(buf)
	})
}

func Fuzz_NetworkTransport_EncodePeer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var id ServerID
		var p ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &id, &p)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.EncodePeer(id, p)
	})
}

func Fuzz_NetworkTransport_InstallSnapshot(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var id ServerID
		var t3 ServerAddress
		var args *InstallSnapshotRequest
		var resp *InstallSnapshotResponse
		var d6 io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &id, &t3, &args, &resp, &d6)
		if config == nil || args == nil || resp == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.InstallSnapshot(id, t3, args, resp, d6)
	})
}

func Fuzz_NetworkTransport_IsShutdown(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.IsShutdown()
	})
}

func Fuzz_NetworkTransport_LocalAddr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.LocalAddr()
	})
}

func Fuzz_NetworkTransport_RequestVote(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var id ServerID
		var t3 ServerAddress
		var args *RequestVoteRequest
		var resp *RequestVoteResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &id, &t3, &args, &resp)
		if config == nil || args == nil || resp == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.RequestVote(id, t3, args, resp)
	})
}

// skipping Fuzz_NetworkTransport_SetHeartbeatHandler because parameters include func, chan, or unsupported interface: func(rpc github.com/hashicorp/raft.RPC)

func Fuzz_NetworkTransport_TimeoutNow(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		var id ServerID
		var t3 ServerAddress
		var args *TimeoutNowRequest
		var resp *TimeoutNowResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &id, &t3, &args, &resp)
		if config == nil || args == nil || resp == nil {
			return
		}

		n := NewNetworkTransportWithConfig(config)
		n.TimeoutNow(id, t3, args, resp)
	})
}

func Fuzz_Observer_GetNumDropped(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var or *Observer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&or)
		if or == nil {
			return
		}

		or.GetNumDropped()
	})
}

func Fuzz_Observer_GetNumObserved(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var or *Observer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&or)
		if or == nil {
			return
		}

		or.GetNumObserved()
	})
}

// skipping Fuzz_RPC_Respond because parameters include func, chan, or unsupported interface: interface{}

func Fuzz_Raft_AddNonvoter(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var id ServerID
		var address ServerAddress
		var prevIndex uint64
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &id, &address, &prevIndex, &timeout)
		if r == nil {
			return
		}

		r.AddNonvoter(id, address, prevIndex, timeout)
	})
}

func Fuzz_Raft_AddPeer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var peer ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &peer)
		if r == nil {
			return
		}

		r.AddPeer(peer)
	})
}

func Fuzz_Raft_AddVoter(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var id ServerID
		var address ServerAddress
		var prevIndex uint64
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &id, &address, &prevIndex, &timeout)
		if r == nil {
			return
		}

		r.AddVoter(id, address, prevIndex, timeout)
	})
}

func Fuzz_Raft_AppliedIndex(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.AppliedIndex()
	})
}

func Fuzz_Raft_Apply(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var cmd []byte
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &cmd, &timeout)
		if r == nil {
			return
		}

		r.Apply(cmd, timeout)
	})
}

func Fuzz_Raft_ApplyLog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var log Log
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &log, &timeout)
		if r == nil {
			return
		}

		r.ApplyLog(log, timeout)
	})
}

func Fuzz_Raft_Barrier(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &timeout)
		if r == nil {
			return
		}

		r.Barrier(timeout)
	})
}

func Fuzz_Raft_BootstrapCluster(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var configuration Configuration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &configuration)
		if r == nil {
			return
		}

		r.BootstrapCluster(configuration)
	})
}

func Fuzz_Raft_DemoteVoter(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var id ServerID
		var prevIndex uint64
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &id, &prevIndex, &timeout)
		if r == nil {
			return
		}

		r.DemoteVoter(id, prevIndex, timeout)
	})
}

func Fuzz_Raft_DeregisterObserver(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var or *Observer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &or)
		if r == nil || or == nil {
			return
		}

		r.DeregisterObserver(or)
	})
}

func Fuzz_Raft_GetConfiguration(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetConfiguration()
	})
}

func Fuzz_Raft_LastContact(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.LastContact()
	})
}

func Fuzz_Raft_LastIndex(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.LastIndex()
	})
}

func Fuzz_Raft_Leader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.Leader()
	})
}

func Fuzz_Raft_LeaderCh(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.LeaderCh()
	})
}

func Fuzz_Raft_LeaderWithID(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.LeaderWithID()
	})
}

func Fuzz_Raft_LeadershipTransfer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.LeadershipTransfer()
	})
}

func Fuzz_Raft_LeadershipTransferToServer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var id ServerID
		var address ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &id, &address)
		if r == nil {
			return
		}

		r.LeadershipTransferToServer(id, address)
	})
}

func Fuzz_Raft_RegisterObserver(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var or *Observer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &or)
		if r == nil || or == nil {
			return
		}

		r.RegisterObserver(or)
	})
}

func Fuzz_Raft_ReloadConfig(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var rc ReloadableConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &rc)
		if r == nil {
			return
		}

		r.ReloadConfig(rc)
	})
}

func Fuzz_Raft_ReloadableConfig(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.ReloadableConfig()
	})
}

func Fuzz_Raft_RemovePeer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var peer ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &peer)
		if r == nil {
			return
		}

		r.RemovePeer(peer)
	})
}

func Fuzz_Raft_RemoveServer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var id ServerID
		var prevIndex uint64
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &id, &prevIndex, &timeout)
		if r == nil {
			return
		}

		r.RemoveServer(id, prevIndex, timeout)
	})
}

func Fuzz_Raft_Restore(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		var meta *SnapshotMeta
		var reader io.Reader
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &meta, &reader, &timeout)
		if r == nil || meta == nil {
			return
		}

		r.Restore(meta, reader, timeout)
	})
}

func Fuzz_Raft_Shutdown(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.Shutdown()
	})
}

func Fuzz_Raft_Snapshot(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.Snapshot()
	})
}

func Fuzz_Raft_State(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.State()
	})
}

func Fuzz_Raft_Stats(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.Stats()
	})
}

func Fuzz_Raft_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.String()
	})
}

func Fuzz_Raft_VerifyLeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *Raft
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.VerifyLeader()
	})
}

func Fuzz_RequestVoteRequest_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *RequestVoteRequest
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_RequestVoteResponse_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *RequestVoteResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_TCPStreamLayer_Accept(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *TCPStreamLayer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		t1.Accept()
	})
}

func Fuzz_TCPStreamLayer_Addr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *TCPStreamLayer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		t1.Addr()
	})
}

func Fuzz_TCPStreamLayer_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *TCPStreamLayer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		t1.Close()
	})
}

func Fuzz_TCPStreamLayer_Dial(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *TCPStreamLayer
		var address ServerAddress
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &address, &timeout)
		if t1 == nil {
			return
		}

		t1.Dial(address, timeout)
	})
}

func Fuzz_TimeoutNowRequest_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *TimeoutNowRequest
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_TimeoutNowResponse_GetRPCHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *TimeoutNowResponse
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetRPCHeader()
	})
}

func Fuzz_ConfigurationChangeCommand_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c ConfigurationChangeCommand
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)

		c.String()
	})
}

func Fuzz_LogType_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var lt LogType
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&lt)

		lt.String()
	})
}

func Fuzz_RaftState_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s RaftState
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)

		s.String()
	})
}

func Fuzz_ServerSuffrage_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s ServerSuffrage
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)

		s.String()
	})
}

// skipping Fuzz_BootstrapCluster because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.LogStore

func Fuzz_DecodeConfiguration(f *testing.F) {
	f.Fuzz(func(t *testing.T, buf []byte) {
		DecodeConfiguration(buf)
	})
}

func Fuzz_EncodeConfiguration(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var configuration Configuration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&configuration)

		EncodeConfiguration(configuration)
	})
}

func Fuzz_FileSnapTest(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *testing.T
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		FileSnapTest(t1)
	})
}

// skipping Fuzz_GetConfiguration because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.FSM

// skipping Fuzz_HasExistingState because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.LogStore

func Fuzz_MakeCluster(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n int
		var t2 *testing.T
		var conf *Config
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &t2, &conf)
		if t2 == nil || conf == nil {
			return
		}

		MakeCluster(n, t2, conf)
	})
}

func Fuzz_MakeClusterCustom(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *testing.T
		var opts *MakeClusterOpts
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &opts)
		if t1 == nil || opts == nil {
			return
		}

		MakeClusterCustom(t1, opts)
	})
}

func Fuzz_MakeClusterNoBootstrap(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n int
		var t2 *testing.T
		var conf *Config
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &t2, &conf)
		if t2 == nil || conf == nil {
			return
		}

		MakeClusterNoBootstrap(n, t2, conf)
	})
}

func Fuzz_NewFileSnapshotStore(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var base string
		var retain int
		var logOutput io.Writer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&base, &retain, &logOutput)

		NewFileSnapshotStore(base, retain, logOutput)
	})
}

// skipping Fuzz_NewFileSnapshotStoreWithLogger because parameters include func, chan, or unsupported interface: github.com/hashicorp/go-hclog.Logger

func Fuzz_NewInmemTransport(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var addr ServerAddress
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&addr)

		NewInmemTransport(addr)
	})
}

func Fuzz_NewInmemTransportWithTimeout(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var addr ServerAddress
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&addr, &timeout)

		NewInmemTransportWithTimeout(addr, timeout)
	})
}

// skipping Fuzz_NewLogCache because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.LogStore

// skipping Fuzz_NewNetworkTransport because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.StreamLayer

func Fuzz_NewNetworkTransportWithConfig(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *NetworkTransportConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		NewNetworkTransportWithConfig(config)
	})
}

// skipping Fuzz_NewNetworkTransportWithLogger because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.StreamLayer

// skipping Fuzz_NewObserver because parameters include func, chan, or unsupported interface: chan github.com/hashicorp/raft.Observation

// skipping Fuzz_NewRaft because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.FSM

// skipping Fuzz_NewTCPTransport because parameters include func, chan, or unsupported interface: net.Addr

// skipping Fuzz_NewTCPTransportWithConfig because parameters include func, chan, or unsupported interface: net.Addr

// skipping Fuzz_NewTCPTransportWithLogger because parameters include func, chan, or unsupported interface: net.Addr

func Fuzz_ReadConfigJSON(f *testing.F) {
	f.Fuzz(func(t *testing.T, path string) {
		ReadConfigJSON(path)
	})
}

func Fuzz_ReadPeersJSON(f *testing.F) {
	f.Fuzz(func(t *testing.T, path string) {
		ReadPeersJSON(path)
	})
}

// skipping Fuzz_RecoverCluster because parameters include func, chan, or unsupported interface: github.com/hashicorp/raft.FSM

func Fuzz_ValidateConfig(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *Config
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		ValidateConfig(config)
	})
}
